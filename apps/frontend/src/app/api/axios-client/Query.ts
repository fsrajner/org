//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../axios-client';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);
import type { AxiosRequestConfig } from 'axios';

export type StockGETQueryParameters = {
  symbol: string ;
}

export type StockPUTQueryParameters = {
  symbol: string ;
}

export type SearchQueryParameters = {
  symbol: string ;
}

export type ChartQueryParameters = {
  symbol: string ;
}

export function stockGETUrl(symbol: string): string {
  let url_ = getBaseUrl() + "/stock/{symbol}";
if (symbol === undefined || symbol === null)
  throw new Error("The parameter 'symbol' must be defined.");
url_ = url_.replace("{symbol}", encodeURIComponent("" + symbol));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let stockGETDefaultOptions: Omit<UseQueryOptions<Types.Anonymous, unknown, Types.Anonymous>, 'queryKey'> = {
  queryFn: __stockGET,
};
export function getStockGETDefaultOptions() {
  return stockGETDefaultOptions;
};
export function setStockGETDefaultOptions(options: typeof stockGETDefaultOptions) {
  stockGETDefaultOptions = options;
}

export function stockGETQueryKey(symbol: string): QueryKey;
export function stockGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { symbol,  } = params[0] as StockGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'stockGET',
        symbol as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'stockGET',
        ...params
      ]);
  }
}
function __stockGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().stockGET(
      context.queryKey[2] as string);
}

export function useStockGETQuery<TSelectData = Types.Anonymous, TError = unknown>(dto: StockGETQueryParameters, options?: Omit<UseQueryOptions<Types.Anonymous, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return SearchResults
 */
export function useStockGETQuery<TSelectData = Types.Anonymous, TError = unknown>(symbol: string, options?: Omit<UseQueryOptions<Types.Anonymous, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useStockGETQuery<TSelectData = Types.Anonymous, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let symbol: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ symbol,  } = params[0] as StockGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [symbol, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __stockGET(context, axiosConfig) : __stockGET,
    queryKey: stockGETQueryKey(symbol),
    ...stockGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.Anonymous, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return SearchResults
 */
export function setStockGETData(queryClient: QueryClient, updater: (data: Types.Anonymous | undefined) => Types.Anonymous, symbol: string) {
  queryClient.setQueryData(stockGETQueryKey(symbol),
    updater
  );
}

/**
 * @return SearchResults
 */
export function setStockGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous | undefined) => Types.Anonymous) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function stockPUTUrl(symbol: string): string {
  let url_ = getBaseUrl() + "/stock/{symbol}";
if (symbol === undefined || symbol === null)
  throw new Error("The parameter 'symbol' must be defined.");
url_ = url_.replace("{symbol}", encodeURIComponent("" + symbol));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function stockPUTMutationKey(symbol: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'stockPUT',
      symbol as any,
    ]);
}

/**
 * @return OK
 */
export function useStockPUTMutation<TContext>(symbol: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = stockPUTMutationKey(symbol);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().stockPUT(symbol),
    mutationKey: key,
  });
}
  
type StockPUT__MutationParameters = StockPUTQueryParameters

/**
 * @return OK
 */
export function useStockPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, StockPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: StockPUTQueryParameters}): UseMutationResult<void, unknown, StockPUT__MutationParameters, TContext> {
  const key = stockPUTMutationKey(options?.parameters?.symbol!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: StockPUT__MutationParameters) => Client().stockPUT(data.symbol ?? options?.parameters?.symbol!),
  mutationKey: key,
});
}
  
export function searchUrl(symbol: string): string {
  let url_ = getBaseUrl() + "/search/{symbol}";
if (symbol === undefined || symbol === null)
  throw new Error("The parameter 'symbol' must be defined.");
url_ = url_.replace("{symbol}", encodeURIComponent("" + symbol));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let searchDefaultOptions: Omit<UseQueryOptions<Types.Anonymous2[], unknown, Types.Anonymous2[]>, 'queryKey'> = {
  queryFn: __search,
};
export function getSearchDefaultOptions() {
  return searchDefaultOptions;
};
export function setSearchDefaultOptions(options: typeof searchDefaultOptions) {
  searchDefaultOptions = options;
}

export function searchQueryKey(symbol: string): QueryKey;
export function searchQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { symbol,  } = params[0] as SearchQueryParameters;

    return trimArrayEnd([
        'Client',
        'search',
        symbol as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'search',
        ...params
      ]);
  }
}
function __search(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().search(
      context.queryKey[2] as string);
}

export function useSearchQuery<TSelectData = Types.Anonymous2[], TError = unknown>(dto: SearchQueryParameters, options?: Omit<UseQueryOptions<Types.Anonymous2[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return SearchResults
 */
export function useSearchQuery<TSelectData = Types.Anonymous2[], TError = unknown>(symbol: string, options?: Omit<UseQueryOptions<Types.Anonymous2[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSearchQuery<TSelectData = Types.Anonymous2[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous2[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let symbol: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ symbol,  } = params[0] as SearchQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [symbol, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous2[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __search(context, axiosConfig) : __search,
    queryKey: searchQueryKey(symbol),
    ...searchDefaultOptions as unknown as Omit<UseQueryOptions<Types.Anonymous2[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return SearchResults
 */
export function setSearchData(queryClient: QueryClient, updater: (data: Types.Anonymous2[] | undefined) => Types.Anonymous2[], symbol: string) {
  queryClient.setQueryData(searchQueryKey(symbol),
    updater
  );
}

/**
 * @return SearchResults
 */
export function setSearchDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous2[] | undefined) => Types.Anonymous2[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function chartUrl(symbol: string): string {
  let url_ = getBaseUrl() + "/chart/{symbol}";
if (symbol === undefined || symbol === null)
  throw new Error("The parameter 'symbol' must be defined.");
url_ = url_.replace("{symbol}", encodeURIComponent("" + symbol));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let chartDefaultOptions: Omit<UseQueryOptions<Types.Anonymous3[], unknown, Types.Anonymous3[]>, 'queryKey'> = {
  queryFn: __chart,
};
export function getChartDefaultOptions() {
  return chartDefaultOptions;
};
export function setChartDefaultOptions(options: typeof chartDefaultOptions) {
  chartDefaultOptions = options;
}

export function chartQueryKey(symbol: string): QueryKey;
export function chartQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { symbol,  } = params[0] as ChartQueryParameters;

    return trimArrayEnd([
        'Client',
        'chart',
        symbol as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'chart',
        ...params
      ]);
  }
}
function __chart(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().chart(
      context.queryKey[2] as string);
}

export function useChartQuery<TSelectData = Types.Anonymous3[], TError = unknown>(dto: ChartQueryParameters, options?: Omit<UseQueryOptions<Types.Anonymous3[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return ChartResult
 */
export function useChartQuery<TSelectData = Types.Anonymous3[], TError = unknown>(symbol: string, options?: Omit<UseQueryOptions<Types.Anonymous3[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useChartQuery<TSelectData = Types.Anonymous3[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous3[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let symbol: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ symbol,  } = params[0] as ChartQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [symbol, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous3[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __chart(context, axiosConfig) : __chart,
    queryKey: chartQueryKey(symbol),
    ...chartDefaultOptions as unknown as Omit<UseQueryOptions<Types.Anonymous3[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return ChartResult
 */
export function setChartData(queryClient: QueryClient, updater: (data: Types.Anonymous3[] | undefined) => Types.Anonymous3[], symbol: string) {
  queryClient.setQueryData(chartQueryKey(symbol),
    updater
  );
}

/**
 * @return ChartResult
 */
export function setChartDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous3[] | undefined) => Types.Anonymous3[]) {
  queryClient.setQueryData(queryKey, updater);
}